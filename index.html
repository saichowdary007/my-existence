<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Interactive Portfolio</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            color: white;
        }
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .content-section {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            max-width: 80%;
            max-height: 80%;
            overflow-y: auto;
            display: none;
            z-index: 10;
        }
        .content-section h2 {
            margin-bottom: 15px;
            color: #00aaff;
        }
        .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
        }
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            color: white;
            font-size: 24px;
        }
        #intro-text {
            position: fixed;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 24px;
            z-index: 5;
            text-shadow: 0 0 10px rgba(0, 150, 255, 0.8);
        }
        @media (max-width: 768px) {
            #intro-text {
                font-size: 18px;
            }
            .content-section {
                max-width: 90%;
            }
        }
    </style>
</head>
<body>
    <div class="loading">Loading 3D Portfolio Experience...</div>
    
    <div id="intro-text">Welcome to my Portfolio - Follow the road to explore</div>
    
    <div id="education-section" class="content-section">
        <button class="close-btn">✕</button>
        <h2>Education</h2>
        <p>
            <strong>Master of Computer Science</strong><br>
            Stanford University | 2019 - 2021<br>
            • Specialization in Computer Graphics and AI<br>
            • Thesis: "Procedural Generation of 3D Environments"
        </p>
        <p>
            <strong>Bachelor of Science in Software Engineering</strong><br>
            MIT | 2015 - 2019<br>
            • Minor in Digital Arts<br>
            • GPA: 3.8/4.0
        </p>
    </div>
    
    <div id="projects-section" class="content-section">
        <button class="close-btn">✕</button>
        <h2>Projects</h2>
        <p>
            <strong>AR Navigation System</strong><br>
            A mobile app using augmented reality to provide navigation guidance in urban environments with real-time object recognition.
        </p>
        <p>
            <strong>Procedural City Generator</strong><br>
            A WebGL-based tool that creates procedurally generated city landscapes with customizable architectural styles.
        </p>
        <p>
            <strong>Interactive Data Visualization</strong><br>
            A 3D visualization framework for complex datasets using Three.js and D3, with interactive elements for data exploration.
        </p>
    </div>
    
    <div id="experience-section" class="content-section">
        <button class="close-btn">✕</button>
        <h2>Experience</h2>
        <p>
            <strong>Senior Frontend Developer</strong><br>
            Google | 2021 - Present<br>
            • Lead developer for WebXR experiences<br>
            • Optimized 3D rendering for web applications<br>
            • Created interactive data visualization tools
        </p>
        <p>
            <strong>Web Graphics Engineer</strong><br>
            Adobe | 2019 - 2021<br>
            • Developed WebGL-based features for Creative Cloud web applications<br>
            • Implemented shader-based effects for image processing
        </p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.7.1/gsap.min.js"></script>
    
    <script>
        // Main Three.js code
        let scene, camera, renderer, car, road;
        let blackHoles = [];
        let particles;
        let clock = new THREE.Clock();
        let carPosition = 0;
        let roadPath;
        let activePath = 0; // 0: main road, 1-3: divergent paths
        let cameraTarget = new THREE.Vector3();
        let isTransitioning = false;
        let sections = ['education', 'projects', 'experience'];
        
        // Initialize the scene
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.01);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 5);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x000000);
            document.body.appendChild(renderer.domElement);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            
            const pointLight = new THREE.PointLight(0xffffff, 1, 100);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);
            
            // Create space background with stars
            createStars();
            
            // Create main road
            createRoad();
            
            // Create car
            createCar();
            
            // Create black holes at the divergent paths
            createBlackHoles();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Add click event listener for raycasting
            window.addEventListener('click', onMouseClick);
            
            // Add close button functionality
            document.querySelectorAll('.close-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    this.parentElement.style.display = 'none';
                    isTransitioning = false;
                });
            });
            
            // Remove loading screen
            setTimeout(() => {
                document.querySelector('.loading').style.display = 'none';
            }, 1500);
            
            // Start animation loop
            animate();
        }
        
        // Create stars background
        function createStars() {
            const starsGeometry = new THREE.BufferGeometry();
            const starsMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.1,
                transparent: true
            });
            
            const starsVertices = [];
            for (let i = 0; i < 3000; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                starsVertices.push(x, y, z);
            }
            
            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
            particles = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(particles);
        }
        
        // Create main road
        function createRoad() {
            // Define the road path
            roadPath = new THREE.CurvePath();
            
            // Main straight road
            const mainCurve = new THREE.LineCurve3(
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 0, -50)
            );
            roadPath.add(mainCurve);
            
            // Create road geometry
            const roadGeometry = new THREE.TubeGeometry(roadPath, 50, 1, 8, false);
            const roadMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x444444, 
                roughness: 0.5, 
                metalness: 0.2
            });
            
            // Add glowing effect on the edges
            const roadEdgeGeometry = new THREE.TubeGeometry(roadPath, 50, 1.05, 8, false);
            const roadEdgeMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00aaff, 
                transparent: true, 
                opacity: 0.5,
                side: THREE.BackSide
            });
            
            road = new THREE.Mesh(roadGeometry, roadMaterial);
            const roadEdge = new THREE.Mesh(roadEdgeGeometry, roadEdgeMaterial);
            scene.add(road);
            scene.add(roadEdge);
            
            // Create divergent paths
            createDivergentPaths();
        }
        
        // Create three divergent paths from the main road
        function createDivergentPaths() {
            const forkPoint = new THREE.Vector3(0, 0, -30);
            
            // Path 1 (left)
            const path1 = new THREE.CurvePath();
            const curve1 = new THREE.QuadraticBezierCurve3(
                forkPoint,
                new THREE.Vector3(-5, 0, -35),
                new THREE.Vector3(-15, 0, -40)
            );
            path1.add(curve1);
            
            // Path 2 (center)
            const path2 = new THREE.CurvePath();
            const curve2 = new THREE.QuadraticBezierCurve3(
                forkPoint,
                new THREE.Vector3(0, 0, -35),
                new THREE.Vector3(0, 0, -50)
            );
            path2.add(curve2);
            
            // Path 3 (right)
            const path3 = new THREE.CurvePath();
            const curve3 = new THREE.QuadraticBezierCurve3(
                forkPoint,
                new THREE.Vector3(5, 0, -35),
                new THREE.Vector3(15, 0, -40)
            );
            path3.add(curve3);
            
            // Add the paths to the scene with glowing materials
            const pathGeometry1 = new THREE.TubeGeometry(curve1, 20, 0.5, 8, false);
            const pathGeometry2 = new THREE.TubeGeometry(curve2, 20, 0.5, 8, false);
            const pathGeometry3 = new THREE.TubeGeometry(curve3, 20, 0.5, 8, false);
            
            const pathMaterial = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.5, metalness: 0.2 });
            const pathEdgeMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00aaff, 
                transparent: true, 
                opacity: 0.5,
                side: THREE.BackSide
            });
            
            const path1Mesh = new THREE.Mesh(pathGeometry1, pathMaterial);
            const path2Mesh = new THREE.Mesh(pathGeometry2, pathMaterial);
            const path3Mesh = new THREE.Mesh(pathGeometry3, pathMaterial);
            
            // Create glowing edges
            const pathEdgeGeometry1 = new THREE.TubeGeometry(curve1, 20, 0.55, 8, false);
            const pathEdgeGeometry2 = new THREE.TubeGeometry(curve2, 20, 0.55, 8, false);
            const pathEdgeGeometry3 = new THREE.TubeGeometry(curve3, 20, 0.55, 8, false);
            
            const path1Edge = new THREE.Mesh(pathEdgeGeometry1, pathEdgeMaterial);
            const path2Edge = new THREE.Mesh(pathEdgeGeometry2, pathEdgeMaterial);
            const path3Edge = new THREE.Mesh(pathEdgeGeometry3, pathEdgeMaterial);
            
            scene.add(path1Mesh, path1Edge);
            scene.add(path2Mesh, path2Edge);
            scene.add(path3Mesh, path3Edge);
        }
        
        // Create the car
        function createCar() {
            // Simple car using a box
            const carGeometry = new THREE.BoxGeometry(0.5, 0.25, 1);
            const carMaterial = new THREE.MeshPhongMaterial({ color: 0x00aaff });
            car = new THREE.Mesh(carGeometry, carMaterial);
            
            // Add glow effect
            const carGlowGeometry = new THREE.BoxGeometry(0.6, 0.35, 1.1);
            const carGlowMaterial = new THREE.MeshBasicMaterial({
                color: 0x00aaff,
                transparent: true,
                opacity: 0.3,
                side: THREE.BackSide
            });
            const carGlow = new THREE.Mesh(carGlowGeometry, carGlowMaterial);
            car.add(carGlow);
            
            scene.add(car);
            
            // Position car at the start of the road
            car.position.set(0, 0.5, 0);
            car.rotation.y = Math.PI;
        }
        
        // Create black holes at the divergent paths
        function createBlackHoles() {
            const blackHolePositions = [
                new THREE.Vector3(-15, 0, -40), // Education
                new THREE.Vector3(0, 0, -50),   // Projects
                new THREE.Vector3(15, 0, -40)   // Experience
            ];
            
            blackHolePositions.forEach((position, index) => {
                // Create black hole core
                const blackHoleGeometry = new THREE.SphereGeometry(1.5, 32, 32);
                const blackHoleMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x000000,
                    transparent: true,
                    opacity: 0.8
                });
                const blackHole = new THREE.Mesh(blackHoleGeometry, blackHoleMaterial);
                blackHole.position.copy(position);
                blackHole.position.y = 1;
                scene.add(blackHole);
                
                // Create glow effect
                const glowGeometry = new THREE.SphereGeometry(2, 32, 32);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00aaff,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.BackSide
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                blackHole.add(glow);
                
                // Add section name
                blackHole.name = sections[index];
                blackHoles.push(blackHole);
                
                // Add light near black hole
                const light = new THREE.PointLight(0x00aaff, 1, 10);
                light.position.copy(position);
                light.position.y += 2;
                scene.add(light);
            });
        }
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Handle mouse click for interacting with black holes
        function onMouseClick(event) {
            if (isTransitioning) return;
            
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects(blackHoles);
            
            if (intersects.length > 0) {
                const clickedHole = intersects[0].object;
                transitionToSection(clickedHole.name);
            }
        }
        
        // Transition to section when black hole is clicked
        function transitionToSection(section) {
            isTransitioning = true;
            
            // Find the black hole position
            const holeName = section;
            const hole = blackHoles.find(h => h.name === holeName);
            
            if (hole) {
                // Animate camera movement to the black hole
                gsap.to(camera.position, {
                    duration: 2,
                    x: hole.position.x,
                    y: hole.position.y + 3,
                    z: hole.position.z + 5,
                    onComplete: () => {
                        // Show content section
                        document.getElementById(`${section}-section`).style.display = 'block';
                    }
                });
                
                // Update camera target
                gsap.to(cameraTarget, {
                    duration: 2,
                    x: hole.position.x,
                    y: hole.position.y,
                    z: hole.position.z
                });
            }
        }
        
        // Move car along the road
        function moveCar() {
            if (isTransitioning) return;
            
            carPosition += 0.05;
            
            // Limit to the fork point
            if (carPosition > 0.6) {
                carPosition = 0.6;
            }
            
            // Get point and tangent on the road curve
            const point = roadPath.getPoint(carPosition);
            const tangent = roadPath.getTangent(carPosition);
            
            // Position the car
            car.position.copy(point);
            car.position.y = 0.5; // Lift car above road
            
            // Orient car along the road
            if (tangent) {
                const axis = new THREE.Vector3(0, 1, 0);
                const radians = Math.atan2(tangent.x, tangent.z);
                car.rotation.set(0, Math.PI + radians, 0);
            }
            
            // Update camera to follow car
            if (carPosition < 0.55) {
                camera.position.set(
                    car.position.x, 
                    car.position.y + 4, 
                    car.position.z + 7
                );
                cameraTarget.copy(car.position);
                cameraTarget.y = car.position.y;
            }
        }
        
        // Animate stars twinkling
        function animateStars() {
            const positions = particles.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                // Slightly move stars for parallax effect
                positions[i + 2] += 0.05;
                
                // Reset stars that go too far
                if (positions[i + 2] > 1000) {
                    positions[i + 2] = -1000;
                }
            }
            particles.geometry.attributes.position.needsUpdate = true;
            
            // Rotate stars slightly for additional effect
            particles.rotation.z += 0.0001;
        }
        
        // Animate black holes
        function animateBlackHoles() {
            const time = clock.getElapsedTime();
            
            blackHoles.forEach((hole, index) => {
                // Make black holes pulse
                const scale = 1 + 0.1 * Math.sin(time * 2 + index);
                hole.scale.set(scale, scale, scale);
                
                // Rotate the glow effect
                if (hole.children.length > 0) {
                    hole.children[0].rotation.y += 0.01;
                    hole.children[0].rotation.z += 0.005;
                }
            });
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            moveCar();
            animateStars();
            animateBlackHoles();
            
            // Update camera target
            camera.lookAt(cameraTarget);
            
            renderer.render(scene, camera);
        }
        
        // Start the application
        init();
    </script>
</body>
</html>
