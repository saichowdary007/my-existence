<!-- Previous HTML content remains the same until the script section -->

    <script>
        // ... (Previous script content up to createBlackHoles() remains unchanged)

        function createBlackHoles() {
            const blackHolePositions = [
                new THREE.Vector3(-15, 0, -40), // Education
                new THREE.Vector3(0, 0, -50),   // Projects
                new THREE.Vector3(15, 0, -40)   // Experience
            ];
            
            blackHolePositions.forEach((position, index) => {
                const blackHoleGeometry = new THREE.SphereGeometry(1.5, 32, 32);
                const blackHoleMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x000000,
                    transparent: true,
                    opacity: 0.9
                });
                const blackHole = new THREE.Mesh(blackHoleGeometry, blackHoleMaterial);
                blackHole.position.copy(position);
                blackHole.position.y = 1;
                blackHole.userData = { section: sections[index] };
                scene.add(blackHole);
                blackHoles.push(blackHole);
                
                const colors = [0x00aaff, 0x0066cc, 0x003399];
                for (let i = 0; i < 3; i++) {
                    const glowGeometry = new THREE.TorusGeometry(2 + i*0.5, 0.1, 16, 32);
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: colors[i],
                        transparent: true,
                        opacity: 0.3 - i*0.05,
                        side: THREE.DoubleSide
                    });
                    const glowRing = new THREE.Mesh(glowGeometry, glowMaterial);
                    glowRing.rotation.x = Math.PI/2;
                    glowRing.userData = {
                        rotationAxis: new THREE.Vector3(
                            Math.random() - 0.5,
                            Math.random() - 0.5, 
                            Math.random() - 0.5
                        ).normalize(),
                        rotationSpeed: 0.005 + Math.random() * 0.01
                    };
                    blackHole.add(glowRing);
                }
                
                const particleCount = 300;
                const particlesGeometry = new THREE.BufferGeometry();
                const particlesMaterial = new THREE.PointsMaterial({
                    color: 0x00aaff,
                    size: 0.05,
                    transparent: true,
                    opacity: 0.7
                });
                
                const particlePositions = new Float32Array(particleCount * 3);
                const particleData = [];
                
                for (let i = 0; i < particleCount; i++) {
                    const radius = 2 + Math.random() * 3;
                    const angle = Math.random() * Math.PI * 2;
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;
                    const y = (Math.random() - 0.5) * 1;
                    
                    particlePositions[i * 3] = x;
                    particlePositions[i * 3 + 1] = y;
                    particlePositions[i * 3 + 2] = z;
                    
                    particleData.push({
                        radius: radius,
                        angle: angle,
                        speed: 0.01 + Math.random() * 0.02
                    });
                }
                
                particlesGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
                const swirlParticles = new THREE.Points(particlesGeometry, particlesMaterial);
                blackHole.add(swirlParticles);
                blackHole.userData.particles = swirlParticles;
                blackHole.userData.particleData = particleData;
            });
        }

        function setupKeyboardControls() {
            window.addEventListener('keydown', (event) => {
                switch(event.key) {
                    case 'ArrowUp': keys.up = true; break;
                    case 'ArrowDown': keys.down = true; break;
                    case 'ArrowLeft': keys.left = true; break;
                    case 'ArrowRight': keys.right = true; break;
                }
            });
            
            window.addEventListener('keyup', (event) => {
                switch(event.key) {
                    case 'ArrowUp': keys.up = false; break;
                    case 'ArrowDown': keys.down = false; break;
                    case 'ArrowLeft': keys.left = false; break;
                    case 'ArrowRight': keys.right = false; break;
                }
            });
        }

        function updateCarMovement() {
            if (keys.up) {
                carSpeed = Math.min(carSpeed + acceleration, maxSpeed);
            } else if (keys.down) {
                carSpeed = Math.max(carSpeed - acceleration, -maxSpeed/2);
            } else {
                carSpeed *= (1 - deceleration);
            }

            if (keys.left) carRotation += turnSpeed;
            if (keys.right) carRotation -= turnSpeed;

            let direction = new THREE.Vector3(Math.sin(carRotation), 0, Math.cos(carRotation));
            carPosition.add(direction.multiplyScalar(carSpeed));
            
            car.position.copy(carPosition);
            car.rotation.y = carRotation;

            // Keep car on path
            let path = activePath === 0 ? mainPath : 
                      activePath === 1 ? path1 : 
                      activePath === 2 ? path2 : path3;
            
            let t = path.getClosestPoint(carPosition);
            if (t > 0.95 && activePath === 0) {
                let closestBlackHole = blackHoles.reduce((prev, curr) => 
                    curr.position.distanceTo(carPosition) < prev.position.distanceTo(carPosition) ? curr : prev
                );
                activePath = sections.indexOf(closestBlackHole.userData.section) + 1;
            }
        }

        function updateCamera() {
            let carDirection = new THREE.Vector3(Math.sin(carRotation), 0, Math.cos(carRotation));
            let desiredPosition = car.position.clone().add(
                carDirection.clone().multiplyScalar(-cameraOffset.z)
            ).add(new THREE.Vector3(0, cameraOffset.y, 0));
            
            camera.position.lerp(desiredPosition, cameraLerp);
            
            let lookAtPosition = car.position.clone().add(
                carDirection.multiplyScalar(cameraLookAhead)
            );
            cameraTarget.lerp(lookAtPosition, cameraLerp);
            camera.lookAt(cameraTarget);
        }

        function animateSolarSystem() {
            sun.rotation.y += 0.001;
            
            planets.forEach(planet => {
                planet.userData.orbitAngle += planet.userData.orbitSpeed;
                planet.position.x = planet.userData.orbitCenter.x + 
                    Math.cos(planet.userData.orbitAngle) * planet.userData.orbitRadius;
                planet.position.z = planet.userData.orbitCenter.z + 
                    Math.sin(planet.userData.orbitAngle) * planet.userData.orbitRadius;
                planet.rotation.y += 0.02;
                
                planet.children.forEach(pivot => {
                    if (pivot.userData.rotationSpeed) {
                        pivot.rotation.z += pivot.userData.rotationSpeed;
                    }
                });
            });
        }

        function animateBlackHoles() {
            blackHoles.forEach(blackHole => {
                blackHole.children.forEach(child => {
                    if (child.userData.rotationSpeed) {
                        child.rotateOnAxis(child.userData.rotationAxis, child.userData.rotationSpeed);
                    }
                });
                
                const positions = blackHole.userData.particles.geometry.attributes.position.array;
                const particleData = blackHole.userData.particleData;
                for (let i = 0; i < particleData.length; i++) {
                    particleData[i].angle += particleData[i].speed;
                    positions[i * 3] = Math.cos(particleData[i].angle) * particleData[i].radius;
                    positions[i * 3 + 2] = Math.sin(particleData[i].angle) * particleData[i].radius;
                }
                blackHole.userData.particles.geometry.attributes.position.needsUpdate = true;
            });
        }

        function checkBlackHoleCollision() {
            blackHoles.forEach(blackHole => {
                const distance = car.position.distanceTo(blackHole.position);
                if (distance < 2 && !isTransitioning) {
                    isTransitioning = true;
                    const sectionId = `${blackHole.userData.section}-section`;
                    const section = document.getElementById(sectionId);
                    gsap.to(section, {
                        duration: 0.5,
                        display: 'block',
                        opacity: 1,
                        ease: 'power2.in'
                    });
                    carSpeed = 0;
                }
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseClick(event) {
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects(blackHoles);
            if (intersects.length > 0 && !isTransitioning) {
                const blackHole = intersects[0].object;
                const sectionId = `${blackHole.userData.section}-section`;
                const section = document.getElementById(sectionId);
                gsap.to(section, {
                    duration: 0.5,
                    display: 'block',
                    opacity: 1,
                    ease: 'power2.in'
                });
                isTransitioning = true;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (!isTransitioning) {
                updateCarMovement();
                updateCamera();
            }
            
            animateSolarSystem();
            animateBlackHoles();
            checkBlackHoleCollision();
            
            particles.rotation.y += 0.0001;
            dustParticles.rotation.y += 0.0002;
            
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
